### 运输层协议概述
- 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。
- 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。
- **网络层和运输层有明显的区别**：网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。
![这里写图片描述](https://img-blog.csdn.net/20180408113511916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。这表明运输层有一个很重要的功能——**复用** (multiplexing)和**分用** (demultiplexing)。
![这里写图片描述](https://img-blog.csdn.net/20180408113646466?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 两种不同的运输协议
当运输层采用面向连接的 **TCP 协议**时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。
当运输层采用无连接的 **UDP 协议**时，这种逻辑通信信道是一条不可靠信道。 
- TCP/IP 的运输层有两个主要协议：
(1) 用户数据报协议 UDP (User Datagram Protocol)
(2) 传输控制协议 TCP (Transmission Control Protocol)
- 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。
TCP 传送的数据单位协议是 **TCP 报文段**(segment)。
 UDP 传送的数据单位协议是 **UDP 报文**或**用户数据报**。 
- TCP：一种面向连接的协议，不提供广播或多播服务。
- 协议端口号 (protocol port number)，或通常简称为端口 (port)：虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。
- 两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。
- 两大类端口 
(1) 服务器端使用的端口号
熟知端口，数值一般为 **0~1023**。
登记端口号，数值为 **1024~49151**，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。
(2) 客户端使用的端口号
又称为短暂端口号，数值为 **49152~65535**，留给客户进程选择暂时使用。
当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 
![这里写图片描述](https://img-blog.csdn.net/20180408114718804?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 用户数据报协议 UDP
- UDP 只在 IP 的数据报服务之上增加了很少一点的功能：
1. 复用和分用的功能
2. 差错检测的功能
- UDP 的主要特点 
(1) UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。
(2) UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
(3) UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。
(4) UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 
(5) UDP 支持一对一、一对多、多对一和多对多的交互通信。
(6) UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。
- 面向报文的 UDP：发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即**一次发送一个报文**。
![这里写图片描述](https://img-blog.csdn.net/2018040819284151?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- UDP 的首部格式 
![这里写图片描述](https://img-blog.csdn.net/20180408193131399?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。
- UDP的检验和是把首部和数据部分一起都检验。

### 传输控制协议 TCP 概述
- 最主要的特点 
1. TCP 是面向连接的运输层协议。
2. 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 
3. TCP 提供可靠交付的服务。
4. TCP 提供全双工通信。
5. 面向字节流
>TCP 中的“流”(stream)指的是流入或流出进程的字节序列。
“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流。

- TCP 面向流的概念 
TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。
但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。
![这里写图片描述](https://img-blog.csdn.net/20180408194501671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。
TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。
- 每一条 TCP 连接有两个端点。TCP 连接的端点叫做套接字 (socket) 或插口。端口号拼接到 (contatenated with) IP 地址即构成了套接字。
- 套接字 (socket)
```
套接字 socket = (IP地址 : 端口号)
```
每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：
```
TCP 连接 ::= {socket1, socket2} 
          = {(IP1: port1)，(IP2: port2)} 
```
- TCP 连接就是由协议软件所提供的一种抽象。TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。同一个 IP 地址可以有多个不同的 TCP 连接。同一个端口号也可以出现在多个不同的 TCP 连接中。
- Socket 有多种不同的意思 
1. 应用编程接口  API  称为 socket API, 简称为 socket。
2. socket API 中使用的一个函数名也叫作 socket。
3. 调用 socket 函数的端点称为 socket。
4. 调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。
5. 在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。    

---
###可靠传输的工作原理
- 理想的传输条件特点
(1) 传输信道不产生差错。
(2) 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。

#### 停止等待协议
- “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
- 全双工通信的双方既是发送方也是接收方。
- 停止等待协议
1. 无差错情况
![这里写图片描述](https://img-blog.csdn.net/20180408195803169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
2. 出现差错
在接收方 B 会出现两种情况：
  - B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。
  -  M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。
  在这两种情况下，B 都不会发送任何信息。如何保证 B 正确收到了 M1 呢？
解决方法：**超时重传**
A 为每一个已发送的分组都设置了一个超时计时器。
A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。
![这里写图片描述](https://img-blog.csdn.net/2018040820402467?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
3. 确认丢失和确认迟到
**确认丢失**
若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。
假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：
  - 第一，丢弃这个重复的分组 M1，不向上层交付。
  - 第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。
**确认迟到**
传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。
  - A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。
  - B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。
![这里写图片描述](https://img-blog.csdn.net/20180408204302395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 注意
1. 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。
2. 分组和确认分组都必须进行编号。
3. 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 
- 自动重传请求 ARQ
1. 通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。
2. 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。
3. 像上述的这种可靠传输协议常称为**自动重传请求 ARQ**  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。
- 停止等待协议的优点是简单，缺点是信道利用率太低。
![这里写图片描述](https://img-blog.csdn.net/2018040820451087?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 流水线传输
流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。
![这里写图片描述](https://img-blog.csdn.net/20180408204634221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

####连续 ARQ 协议
- 发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。
连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。
![这里写图片描述](https://img-blog.csdn.net/20180408205004228?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 累积确认 
接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。
**优点**：容易实现，即使确认丢失也不必重传。
**缺点**：不能向发送方反映出接收方已经正确收到的所有分组的信息。
- Go-back-N（回退 N）:如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。
- TCP 可靠通信的具体实现 
1. TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。
2. TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。
3. TCP 两端的四个窗口经常处于动态变化之中。

### TCP 报文段的首部格式
- TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。
- TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。
- TCP 报文段的首部格式 
![这里写图片描述](https://img-blog.csdn.net/20180408205405516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
1. 源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。  
2. 序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 
3. 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。 
4. 数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。  
5. 保留字段——占 6 位，保留为今后使用，但目前应置为 0。 
6. 紧急 URG —— 当 URG =1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 
7. 确认 ACK —— 只有当 ACK= 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。 
8. 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。  
9. 复位 RST (ReSeT) —— 当 RST  1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 
10. 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。 
11. 终止 FIN (FINish) —— 用来释放一个连接。FIN  1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 
12. 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。
13. 检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
14. 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  
15. 选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” 
>MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，**MSS是“TCP 报文段长度减去 TCP 首部长度”**。

16. 其他选项
    - 窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数增大到 (16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。
  -  时间戳选项——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。
  - 选择确认选项——在后面介绍。 
19. 填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。 

### TCP 可靠传输的实现
#### 以字节为单位的滑动窗口
- TCP 的滑动窗口是以字节为单位的。
![这里写图片描述](https://img-blog.csdn.net/20180408212741197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![这里写图片描述](https://img-blog.csdn.net/20180408212802404?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
![这里写图片描述](https://img-blog.csdn.net/20180408212828549?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 发送缓存 
![这里写图片描述](https://img-blog.csdn.net/20180408212900760?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 接收缓存
![这里写图片描述](https://img-blog.csdn.net/20180408212925114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 发送缓存与接收缓存的作用
发送缓存用来暂时存放：
  1. 发送应用程序传送给发送方 TCP 准备发送的数据；
  2. TCP 已发送出但尚未收到确认的数据。
接收缓存用来暂时存放：
  1. 按序到达的、但尚未被接收应用程序读取的数据；
  2. 不按序到达的数据。 
- 需要强调三点
第一，A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。
第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。  
- 接收方发送确认
接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。

#### 超时重传时间的选择
- 重传机制是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。重传时间的选择是 TCP 最复杂的问题之一。
- 往返时延的方差很大
![这里写图片描述](https://img-blog.csdn.net/20180408213217919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- TCP 超时重传时间设置
TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）。第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：
![这里写图片描述](https://img-blog.csdn.net/20180408213351538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
式中，0 <=\alpha<1。若 \alpha 很接近于零，表示 RTT 值更新较慢。若选择\alpha 接近于 1，则表示 RTT 值更新较快。
RFC 2988 推荐的 \alpha值为 1/8，即 0.125。 
- 超时重传时间 RTO
RTO (Retransmission Time-Out) 应略大于上面得出的加权平均往返时间 RTTS。
RFC 2988 建议使用下式计算 RTO：
![这里写图片描述](https://img-blog.csdn.net/20180408213507161?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- RTTD 是 RTT 的偏差的加权平均值。
RFC 2988 建议这样计算 RTTD。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD：
![这里写图片描述](https://img-blog.csdn.net/20180408213550861?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
\beta是个小于 1 的系数，其推荐值是 1/4，即 0.25。
- 往返时间 (RTT) 的测量相当复杂 
TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。
如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ 
![这里写图片描述](https://img-blog.csdn.net/20180408213719638?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
Karn 算法解决
- Karn 算法 
在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。
这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。
- 修正的 Karn 算法 
报文段每重传一次，就把 RTO 增大一些：
![这里写图片描述](https://img-blog.csdn.net/20180408213832377?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
系数 \gamma的典型值是 2 。

#### 选择确认 SACK
- 若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？
答案是可以的。选择确认 SACK  (Selective ACK) 就是一种可行的处理方法。
接收方收到了和前面的字节流不连续的两个字节块。
如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。
- RFC 2018 的规定
1. 如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。
2. 如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。
3. 由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。

### TCP 的流量控制
- 流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。
- 利用可变窗口进行流量控制举例
![这里写图片描述](https://img-blog.csdn.net/20180409153743378?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 可能发生死锁
B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。为了解决这个问题，TCP 为每一个连接设有一个**持续计时器** (persistence timer)。
- 持续计时器
TCP 为每一个连接设有一个持续计时器  (persistence timer) 。只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。

#### 必须考虑传输效率
- 可以用不同的机制来控制 TCP 报文段的发送时机:
1. 第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。
2. 第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push)操作。
3. 第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。
- 发送方糊涂窗口综合症
发送方 TCP 每次接收到一字节的数据后就发送。这样，发送一个字节需要形成 41 字节长的 IP 数据报。若接收方确认，并回送这一字节，就需传送总长度为 162 字节共 4 个报文段。效率很低。
解决方法：**使用 Nagle 算法**。
- Nagle算法
若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。
- 接收方糊涂窗口综合症
当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。
解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。

---
### TCP 的拥塞控制
- 拥塞控制的一般原理
在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为**拥塞** (congestion)。
- 出现拥塞的原因：
![这里写图片描述](https://img-blog.csdn.net/20180409160330527?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。
- 拥塞控制与流量控制的区别 
拥塞控制就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。 
流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 
- 拥塞控制所起的作用 
![这里写图片描述](https://img-blog.csdn.net/20180409161253579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 开环控制和闭环控制 
开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。 
闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施： 
(1) 监测网络系统以便检测到拥塞在何时、何处发生。
(2) 将拥塞发生的信息传送到可采取行动的地方。
(3) 调整网络系统的运行以解决出现的问题。
- 监测网络的拥塞的指标
主要指标有：
1. 由于缺少缓存空间而被丢弃的分组的百分数；
2. 平均队列长度；
3. 超时重传的分组数；
4. 平均分组时延；
5. 分组时延的标准差，等等。
上述这些指标的上升都标志着拥塞的增长。

#### TCP 的拥塞控制方法
- TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。TCP发送方维持一个拥塞窗口 CWND (Congestion Window)
![这里写图片描述](https://img-blog.csdn.net/2018040916161897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 拥塞的判断
1. 重传定时器超时
现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于 1 %）。只要出现了超时，就可以猜想网络可能出现了拥塞。
2. 收到三个相同（重复）的 ACK
个别报文段会在网络中丢失，预示可能会出现拥塞（实际未发生拥塞），因此可以尽快采取控制措施，避免拥塞。
- TCP拥塞控制算法
四种（ RFC 5681） ：
1. 慢开始 (slow-start)
2. 拥塞避免 (congestion avoidance)
3. 快重传 (fast retransmit)
4. 快恢复 (fast recovery)
- 慢开始 (Slow start)
算法的思路：由小到大逐渐增大拥塞窗口数值。
初始拥塞窗口 cwnd 设置：
旧的规定：在刚刚开始发送报文段时，先把初始拥塞窗口cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS (Sender Maximum Segment Size) 的数值。
新的 RFC 5681 把初始拥塞窗口 cwnd 设置为不超过2至4个SMSS 的数值。
慢开始门限 ssthresh（状态变量）：防止拥塞窗口cwnd 增长过大引起网络拥塞。
- 拥塞窗口 cwnd  控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个 SMSS 的数值。
![这里写图片描述](https://img-blog.csdn.net/20180409161939757?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
其中 N 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。不难看出，当 N < SMSS 时，拥塞窗口每次的增加量要小于 SMSS。用这样的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。
![这里写图片描述](https://img-blog.csdn.net/20180409212819953?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 传输轮次
使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍。 
- 慢开始门限 ssthresh 的用法如下：
当 cwnd < ssthresh 时，使用慢开始算法。
当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。
- 拥塞避免算法
在拥塞避免阶段就有“加法增大”  (Additive Increase) 的特点。
**思路**：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。
- 当网络出现拥塞时
无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）：
1. ssthresh = max(cwnd/2，2)
2. cwnd = 1
3. 执行慢开始算法
- 执行过程 
![这里写图片描述](https://img-blog.csdn.net/20180409213143758?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。
1. 在执行慢开始算法时，拥塞窗口 cwnd=1，发送第一个报文段。
2. 发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。
3. 当拥塞窗口 cwnd 增长到慢开始门限值s sthresh 时（图中的点，此时拥塞窗口cwnd = 16），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。
  >“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。
 
4. 当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点2），发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段。
5. 按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1。当拥塞窗口cwnd = ssthresh = 12时（图中的点，这是新的ssthresh值），改为执行拥塞避免算法，拥塞窗口按线性规律增大。
6. 当拥塞窗口cwnd = 16时（图中的点4），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中记为3-ACK）。发送方改为执行快重传和快恢复算法。
- 快重传算法
采用快重传FR (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。
快重传 算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。
使用快重传可以使整个网络的吞吐量提高约20%。 
![这里写图片描述](https://img-blog.csdn.net/20180409215314423?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 快恢复算法
(1) 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；
(2) 新拥塞窗口 cwnd = 慢开始门限 ssthresh ；
(3) 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 
在图的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值ssthresh = cwnd / 2 = 8，同时设置拥塞窗口cwnd = ssthresh = 8（见图中的点5），并开始执行拥塞避免算法。
- 加法增大，乘法减小 (AIMD)
可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“加法增大” AI (Additive Increase)。
当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD (Multiplicative Decrease)。
二者合在一起就是所谓的 AIMD 算法。
- TCP拥塞控制流程图
![这里写图片描述](https://img-blog.csdn.net/20180409215638526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 发送窗口的上限值
![这里写图片描述](https://img-blog.csdn.net/20180409215734314?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。
当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。 

#### 主动队列管理 AQM
- 全局同步
若发生了路由器中的尾部丢弃，就可能会同时影响到很多条 TCP 连接，结果使这许多 TCP 连接在同一时间突然都进入到慢开始状态。这在 TCP 的术语中称为全局同步 (global syncronization)。
- 主动队列管理AQM
所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。AQM 可以有不同实现方法，其中曾流行多年的就是**随机早期检测 RED** (Random Early Detection)。
- 随机早期检测 RED
使路由器的队列维持两个参数：队列长度最小门限 THmin 和最大门限 Thmax 。
RED 对每一个到达的分组都先计算平均队列长度 LAV 。
(1) 若平均队列长度小于最小门限 THmin，则将新到达的分组放入队列进行排队。
(2) 若平均队列长度超过最大门限 THmax，则将新到达的分组丢弃。
(3) 若平均队列长度在最小门限 THmin 和最大门限THmax 之间，则按照某一概率 p 将新到达的分组丢弃。
![这里写图片描述](https://img-blog.csdn.net/2018040922013192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- 多年的实践证明，RED 的使用效果并不太理想。2015年公布的 RFC 7567 已经把 RFC 2309列为陈旧的，并且不再推荐使用 RED。对路由器进行主动队列管理 AQM 仍是必要的。AQM 实际上就是对路由器中的分组排队进行智能管理，而不是简单地把队列的尾部丢弃。现在已经有几种不同的算法来代替旧的 RED，但都还在**实验阶段**。

### TCP 的运输连接管理
- 运输连接有三个阶段：
1. 连接建立
2. 数据传送
3. 连接释放
- TCP 连接建立过程中要解决的三个问题
(1) 要使每一方能够确知对方的存在。
(2) 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。
(3) 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。
- TCP连接的建立采用**客户服务器方式**。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。

#### TCP 的连接建立
- TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。
![这里写图片描述](https://img-blog.csdn.net/20180409221350308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### TCP 的连接释放
- TCP 连接释放过程比较复杂。数据传输结束后，通信的双方都可释放连接。TCP 连接释放过程是四报文握手。
![这里写图片描述](https://img-blog.csdn.net/20180409221438662?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- A 必须等待 2MSL 的时间
1. 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。
2. 防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

#### TCP 的有限状态机
- TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。
- 图中有三种不同的箭头。
1. 粗实线箭头表示对客户进程的正常变迁。
2. 粗虚线箭头表示对服务器进程的正常变迁。
3. 细线箭头表示异常变迁。 
![这里写图片描述](https://img-blog.csdn.net/20180409221709857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2J1Y3RfemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
